import{_ as i,o as s,c as a,R as e}from"./chunks/framework.rSPAVkc7.js";const E=JSON.parse('{"title":"数据类型与类型转换","description":"","frontmatter":{},"headers":[],"relativePath":"前端面试学习/01JavaScript基础/01数据类型与类型转换.md","filePath":"前端面试学习/01JavaScript基础/01数据类型与类型转换.md"}'),t={name:"前端面试学习/01JavaScript基础/01数据类型与类型转换.md"},o=e('<h1 id="数据类型与类型转换" tabindex="-1">数据类型与类型转换 <a class="header-anchor" href="#数据类型与类型转换" aria-label="Permalink to &quot;数据类型与类型转换&quot;">​</a></h1><h2 id="题目1-javascript中有哪些基本数据类型" tabindex="-1">题目1: JavaScript中有哪些基本数据类型？ <a class="header-anchor" href="#题目1-javascript中有哪些基本数据类型" aria-label="Permalink to &quot;题目1: JavaScript中有哪些基本数据类型？&quot;">​</a></h2><p><strong>答案</strong>: JavaScript中的基本数据类型包括：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code>（ES6引入）和<code>bigint</code>（ES11引入）。</p><p><strong>扩展</strong>: 除了基本数据类型，JavaScript还有一种复杂数据类型：<code>object</code>。<code>object</code>包括对象、数组、函数等。基本数据类型存储的是值，而复杂数据类型存储的是引用地址。</p><h2 id="题目2-和-的区别是什么" tabindex="-1">题目2: <code>==</code>和<code>===</code>的区别是什么？ <a class="header-anchor" href="#题目2-和-的区别是什么" aria-label="Permalink to &quot;题目2: `==`和`===`的区别是什么？&quot;">​</a></h2><p><strong>答案</strong>: <code>==</code>进行的是类型转换的比较，<code>===</code>进行的是严格比较，不会进行类型转换。使用<code>===</code>可以避免隐式类型转换带来的问题，推荐使用。</p><p><strong>扩展</strong>: <code>==</code>会在比较前尝试进行类型转换，比如数字与字符串进行比较时会将字符串转换为数字。例如：<code>1 == &#39;1&#39;</code>返回<code>true</code>，而<code>1 === &#39;1&#39;</code>返回<code>false</code>。</p><h2 id="题目3-如何检测一个变量的类型-typeof、instanceof和object-prototype-tostring-call-的区别" tabindex="-1">题目3: 如何检测一个变量的类型？<code>typeof</code>、<code>instanceof</code>和<code>Object.prototype.toString.call()</code>的区别？ <a class="header-anchor" href="#题目3-如何检测一个变量的类型-typeof、instanceof和object-prototype-tostring-call-的区别" aria-label="Permalink to &quot;题目3: 如何检测一个变量的类型？`typeof`、`instanceof`和`Object.prototype.toString.call()`的区别？&quot;">​</a></h2><p><strong>答案</strong>:</p><ul><li><code>typeof</code>操作符可以检测基本数据类型（除了<code>null</code>）和函数。</li><li><code>instanceof</code>用于检测对象是否为某个构造函数的实例。</li><li><code>Object.prototype.toString.call()</code>可以精确地检测任何类型。</li></ul><p><strong>扩展</strong>:</p><ul><li><code>typeof null</code>返回<code>&quot;object&quot;</code>，这是JavaScript的一个历史遗留bug。</li><li><code>instanceof</code>不能跨框架（iframe）使用，因为每个框架都有自己的执行环境。</li><li><code>Object.prototype.toString.call()</code>返回形如<code>&quot;[object Type]&quot;</code>的字符串，其中<code>Type</code>是对象的实际类型。</li></ul><h2 id="题目4-什么时候会发生隐式类型转换-如何避免" tabindex="-1">题目4: 什么时候会发生隐式类型转换？如何避免？ <a class="header-anchor" href="#题目4-什么时候会发生隐式类型转换-如何避免" aria-label="Permalink to &quot;题目4: 什么时候会发生隐式类型转换？如何避免？&quot;">​</a></h2><p><strong>答案</strong>: 隐式类型转换主要发生在以下情况：</p><ol><li>使用<code>==</code>进行比较</li><li>使用<code>+</code>运算符时，如果有一个操作数是字符串</li><li>逻辑运算符（<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>）</li><li>条件语句中的条件表达式</li></ol><p>避免隐式类型转换的方法：</p><ol><li>使用<code>===</code>和<code>!==</code>进行比较</li><li>在进行运算前，显式地将变量转换为期望的类型</li><li>使用类型检查函数（如<code>typeof</code>）来确保类型正确</li></ol><p><strong>扩展</strong>: 隐式类型转换可能导致意外的结果，例如：<code>[] + {}</code>返回<code>&quot;[object Object]&quot;</code>，而<code>{} + []</code>返回<code>0</code>。这是因为JavaScript引擎对这两种表达式的解析方式不同。</p><h2 id="题目5-nan是什么-如何检测一个值是否为nan" tabindex="-1">题目5: <code>NaN</code>是什么？如何检测一个值是否为<code>NaN</code>？ <a class="header-anchor" href="#题目5-nan是什么-如何检测一个值是否为nan" aria-label="Permalink to &quot;题目5: `NaN`是什么？如何检测一个值是否为`NaN`？&quot;">​</a></h2><p><strong>答案</strong>: <code>NaN</code>表示&quot;Not a Number&quot;（不是一个数字），它是一个特殊的数值，用于表示某个值不是合法的数字。检测一个值是否为<code>NaN</code>的最可靠方法是使用<code>Number.isNaN()</code>函数。</p><p><strong>扩展</strong>:</p><ul><li><code>NaN</code>不等于任何值，包括它自己。因此，<code>NaN === NaN</code>返回<code>false</code>。</li><li><code>typeof NaN</code>返回<code>&quot;number&quot;</code>，这可能会让人感到困惑。</li><li>早期的<code>isNaN()</code>函数存在问题，它会将非数字值（如字符串）也判断为<code>NaN</code>。ES6引入的<code>Number.isNaN()</code>修复了这个问题。</li></ul><h2 id="题目6-javascript中的数字精度问题是如何产生的-如何处理" tabindex="-1">题目6: JavaScript中的数字精度问题是如何产生的？如何处理？ <a class="header-anchor" href="#题目6-javascript中的数字精度问题是如何产生的-如何处理" aria-label="Permalink to &quot;题目6: JavaScript中的数字精度问题是如何产生的？如何处理？&quot;">​</a></h2><p><strong>答案</strong>: JavaScript使用IEEE 754标准的双精度浮点数来表示数字，这会导致某些小数无法精确表示，比如<code>0.1 + 0.2 !== 0.3</code>。</p><p>处理方法：</p><ol><li>对于金融计算，可以将小数转换为整数进行计算，然后再除以相应的倍数。</li><li>使用专门的库，如<code>decimal.js</code>或<code>big.js</code>。</li><li>使用<code>Number.EPSILON</code>进行近似相等比较。</li></ol><p><strong>扩展</strong>: <code>Number.EPSILON</code>是JavaScript能够表示的最小精度。对于比较小数是否相等，可以使用如下函数：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> areEqual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">abs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Number.EPSILON;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="题目7-解释一下javascript中的装箱和拆箱操作。" tabindex="-1">题目7: 解释一下JavaScript中的装箱和拆箱操作。 <a class="header-anchor" href="#题目7-解释一下javascript中的装箱和拆箱操作。" aria-label="Permalink to &quot;题目7: 解释一下JavaScript中的装箱和拆箱操作。&quot;">​</a></h2><p><strong>答案</strong>:</p><ul><li>装箱（Boxing）：将基本数据类型转换为对应的引用类型的操作。例如，将<code>number</code>类型转换为<code>Number</code>对象。</li><li>拆箱（Unboxing）：将引用类型转换为对应的基本数据类型的操作。</li></ul><p><strong>扩展</strong>:</p><ul><li>装箱操作通常是隐式的，例如调用基本类型的方法时（如<code>&quot;hello&quot;.toUpperCase()</code>）。</li><li>拆箱操作通常通过<code>valueOf()</code>或<code>toString()</code>方法实现。</li><li>过度使用装箱和拆箱操作可能会影响性能，特别是在循环中。</li></ul><h2 id="题目8-什么是类型强制转换-请举例说明。" tabindex="-1">题目8: 什么是类型强制转换？请举例说明。 <a class="header-anchor" href="#题目8-什么是类型强制转换-请举例说明。" aria-label="Permalink to &quot;题目8: 什么是类型强制转换？请举例说明。&quot;">​</a></h2><p><strong>答案</strong>: 类型强制转换是指将一种数据类型的值转换为另一种数据类型的值。JavaScript中的强制类型转换主要有以下几种：</p><ol><li>转换为字符串：使用<code>String()</code>函数或者<code>toString()</code>方法</li><li>转换为数字：使用<code>Number()</code>函数、一元加操作符（<code>+</code>）或<code>parseInt()</code>/<code>parseFloat()</code>函数</li><li>转换为布尔值：使用<code>Boolean()</code>函数或者<code>!!</code>操作符</li></ol><p><strong>扩展</strong>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;123&quot;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;123&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;123&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 123</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;123&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 123</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parseInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;123&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 123</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><h2 id="题目9-object-is-与-有什么区别" tabindex="-1">题目9: <code>Object.is()</code>与<code>===</code>有什么区别？ <a class="header-anchor" href="#题目9-object-is-与-有什么区别" aria-label="Permalink to &quot;题目9: `Object.is()`与`===`有什么区别？&quot;">​</a></h2><p><strong>答案</strong>: <code>Object.is()</code>和<code>===</code>大多数情况下的行为是相同的，但有两个特殊情况：</p><ol><li><code>Object.is(NaN, NaN)</code>返回<code>true</code>，而<code>NaN === NaN</code>返回<code>false</code></li><li><code>Object.is(+0, -0)</code>返回<code>false</code>，而<code>+0 === -0</code>返回<code>true</code></li></ol><p><strong>扩展</strong>: <code>Object.is()</code>是ES6引入的新方法，用于解决<code>===</code>在处理<code>NaN</code>和正负零时的一些特殊情况。在大多数情况下，使用<code>===</code>就足够了，但如果需要区分<code>+0</code>和<code>-0</code>，或者需要将<code>NaN</code>视为相等，那么<code>Object.is()</code>会更合适。</p><h2 id="题目10-解释一下javascript中的真值-truthy-和假值-falsy-。" tabindex="-1">题目10: 解释一下JavaScript中的真值（truthy）和假值（falsy）。 <a class="header-anchor" href="#题目10-解释一下javascript中的真值-truthy-和假值-falsy-。" aria-label="Permalink to &quot;题目10: 解释一下JavaScript中的真值（truthy）和假值（falsy）。&quot;">​</a></h2><p><strong>答案</strong>: 在JavaScript中，当一个值在布尔上下文中被评估时，它会被强制转换为布尔值<code>true</code>或<code>false</code>。</p><p>假值（Falsy）包括：</p><ul><li><code>false</code></li><li><code>0</code></li><li><code>&#39;&#39;</code>（空字符串）</li><li><code>null</code></li><li><code>undefined</code></li><li><code>NaN</code></li></ul><p>除了这些假值，其他所有值都是真值（Truthy）。</p><p><strong>扩展</strong>:</p><ul><li>空数组（<code>[]</code>）和空对象（<code>{}</code>）都是真值，这可能会导致一些意外情况。</li><li>在条件语句中，JavaScript会自动进行布尔转换，例如：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ([]) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;This will be executed!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li>使用双重否定（<code>!!</code>）可以将任何值显式转换为其对应的布尔值：<div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // false</span></span></code></pre></div></li></ul>',49),l=[o];function c(n,d,p,h,r,k){return s(),a("div",null,l)}const u=i(t,[["render",c]]);export{E as __pageData,u as default};
