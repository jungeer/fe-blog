import{_ as s,o as i,c as a,R as n}from"./chunks/framework.rSPAVkc7.js";const c=JSON.parse('{"title":"事件循环与任务队列","description":"","frontmatter":{},"headers":[],"relativePath":"前端面试学习/01JavaScript基础/05事件循环与任务队列.md","filePath":"前端面试学习/01JavaScript基础/05事件循环与任务队列.md"}'),t={name:"前端面试学习/01JavaScript基础/05事件循环与任务队列.md"},l=n(`<h1 id="事件循环与任务队列" tabindex="-1">事件循环与任务队列 <a class="header-anchor" href="#事件循环与任务队列" aria-label="Permalink to &quot;事件循环与任务队列&quot;">​</a></h1><h2 id="题目1-解释事件循环机制-什么是微任务和宏任务" tabindex="-1">题目1: 解释事件循环机制，什么是微任务和宏任务？ <a class="header-anchor" href="#题目1-解释事件循环机制-什么是微任务和宏任务" aria-label="Permalink to &quot;题目1: 解释事件循环机制，什么是微任务和宏任务？&quot;">​</a></h2><p><strong>答案</strong>: 事件循环是JavaScript的一种机制，用于执行代码、收集和处理事件以及执行排队的子任务。</p><p>微任务和宏任务是两种不同类型的任务：</p><ul><li>微任务（Microtask）：优先级较高，在当前任务执行结束后立即执行。例如Promise的回调、MutationObserver等。</li><li>宏任务（Macrotask）：优先级较低，在下一次事件循环中执行。例如setTimeout、setInterval、I/O操作等。</li></ul><p>事件循环的基本过程：</p><ol><li>执行同步代码，这属于宏任务</li><li>执行完所有同步代码后，执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>执行完所有微任务后，如有必要会渲染页面</li><li>开始下一轮事件循环，执行宏任务中的异步代码</li></ol><p><strong>扩展</strong>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;4&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出顺序：1, 4, 3, 2</span></span></code></pre></div><h2 id="题目2-settimeout-和-promise-的执行顺序如何" tabindex="-1">题目2: <code>setTimeout</code> 和 <code>Promise</code> 的执行顺序如何？ <a class="header-anchor" href="#题目2-settimeout-和-promise-的执行顺序如何" aria-label="Permalink to &quot;题目2: \`setTimeout\` 和 \`Promise\` 的执行顺序如何？&quot;">​</a></h2><p><strong>答案</strong>: <code>Promise</code> 的回调（<code>.then()</code>、<code>.catch()</code>）属于微任务，而 <code>setTimeout</code> 的回调属于宏任务。在事件循环中，微任务总是在下一个宏任务之前执行。</p><p>因此，即使 <code>setTimeout</code> 的延迟时间设置为0，<code>Promise</code> 的回调也会先于 <code>setTimeout</code> 的回调执行。</p><p><strong>扩展</strong>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;timeout&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;sync&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出顺序：sync, promise, timeout</span></span></code></pre></div><h2 id="题目3-什么是-requestanimationframe-如何优化动画" tabindex="-1">题目3: 什么是 <code>requestAnimationFrame</code>，如何优化动画？ <a class="header-anchor" href="#题目3-什么是-requestanimationframe-如何优化动画" aria-label="Permalink to &quot;题目3: 什么是 \`requestAnimationFrame\`，如何优化动画？&quot;">​</a></h2><p><strong>答案</strong>: <code>requestAnimationFrame</code> 是浏览器用于定时循环操作的一个接口，主要用于动画，使用这个API，可以在浏览器下一次重绘之前执行指定的回调函数。</p><p>优化动画的方法：</p><ol><li>使用 <code>requestAnimationFrame</code> 代替 <code>setTimeout</code> 或 <code>setInterval</code></li><li>避免频繁的DOM操作，可以使用虚拟DOM</li><li>使用 CSS3 动画代替 JavaScript 动画</li><li>使用 <code>transform</code> 和 <code>opacity</code> 属性进行动画，因为这些属性可以由 GPU 加速</li></ol><p><strong>扩展</strong>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> animate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 更新动画</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    updateAnimation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 继续下一帧</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animate);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开始动画</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(animate);</span></span></code></pre></div><h2 id="题目4-如何理解javascript的单线程特性" tabindex="-1">题目4: 如何理解JavaScript的单线程特性？ <a class="header-anchor" href="#题目4-如何理解javascript的单线程特性" aria-label="Permalink to &quot;题目4: 如何理解JavaScript的单线程特性？&quot;">​</a></h2><p><strong>答案</strong>: JavaScript是单线程的，这意味着它只有一个调用栈，同一时间只能执行一个任务。这个特性是为了简化编程模型，避免多线程编程中的复杂性。</p><p>单线程的影响：</p><ol><li>长时间运行的脚本会阻塞页面响应</li><li>需要使用异步编程来处理耗时操作</li><li>事件循环和任务队列的概念由此产生</li></ol><p><strong>扩展</strong>: 虽然JavaScript是单线程的，但浏览器不是。浏览器可以使用Web Workers在后台线程中运行脚本，不会影响页面的性能。</p><h2 id="题目5-什么是任务队列-task-queue-它在事件循环中的作用是什么" tabindex="-1">题目5: 什么是任务队列（Task Queue）？它在事件循环中的作用是什么？ <a class="header-anchor" href="#题目5-什么是任务队列-task-queue-它在事件循环中的作用是什么" aria-label="Permalink to &quot;题目5: 什么是任务队列（Task Queue）？它在事件循环中的作用是什么？&quot;">​</a></h2><p><strong>答案</strong>: 任务队列是一个先进先出的队列，用于存储待执行的任务（主要是回调函数）。在事件循环中，当主线程空闲时，会从任务队列中取出任务执行。</p><p>任务队列的作用：</p><ol><li>存储异步操作的回调函数</li><li>确保任务按照正确的顺序执行</li><li>防止长时间运行的任务阻塞主线程</li></ol><p><strong>扩展</strong>: 实际上，浏览器维护多个任务队列，不同类型的任务可能在不同的队列中。例如，鼠标点击事件和 setTimeout 回调可能在不同的队列中。</p><h2 id="题目6-解释一下-javascript-中的-堆-和-栈-。" tabindex="-1">题目6: 解释一下 JavaScript 中的 &quot;堆&quot; 和 &quot;栈&quot;。 <a class="header-anchor" href="#题目6-解释一下-javascript-中的-堆-和-栈-。" aria-label="Permalink to &quot;题目6: 解释一下 JavaScript 中的 &quot;堆&quot; 和 &quot;栈&quot;。&quot;">​</a></h2><p><strong>答案</strong>:</p><ul><li>堆（Heap）：用于存储对象、数组等复杂数据类型。</li><li>栈（Stack）：用于存储基本数据类型和对象的引用。</li></ul><p>特点：</p><ul><li>栈的分配速度比堆快，但容量有限。</li><li>堆的分配速度较慢，但容量大。</li></ul><p><strong>扩展</strong>: 当我们创建一个对象时，对象本身存储在堆中，而对象的引用存储在栈中。这就是为什么对象是按引用传递的原因。</p><h2 id="题目7-什么是-web-workers-它们如何影响事件循环" tabindex="-1">题目7: 什么是 Web Workers？它们如何影响事件循环？ <a class="header-anchor" href="#题目7-什么是-web-workers-它们如何影响事件循环" aria-label="Permalink to &quot;题目7: 什么是 Web Workers？它们如何影响事件循环？&quot;">​</a></h2><p><strong>答案</strong>: Web Workers 是一种可以在后台线程中运行脚本的技术，不会影响页面的性能。</p><p>Web Workers 的特点：</p><ol><li>可以执行长时间运行的脚本而不阻塞主线程</li><li>不能直接访问 DOM</li><li>通过消息传递与主线程通信</li></ol><p>Web Workers 对事件循环的影响：</p><ul><li>Web Workers 有自己的事件循环，不会直接影响主线程的事件循环</li><li>主线程可以通过 postMessage 向 Worker 发送消息，这个操作是异步的</li></ul><p><strong>扩展</strong>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个新的 Worker</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> worker</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Worker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;worker.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 向 Worker 发送消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, Worker!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 接收 Worker 的消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">worker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Received from worker:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.data);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="题目8-解释一下-javascript-中的-死锁-概念。" tabindex="-1">题目8: 解释一下 JavaScript 中的 &quot;死锁&quot; 概念。 <a class="header-anchor" href="#题目8-解释一下-javascript-中的-死锁-概念。" aria-label="Permalink to &quot;题目8: 解释一下 JavaScript 中的 &quot;死锁&quot; 概念。&quot;">​</a></h2><p><strong>答案</strong>: 虽然 JavaScript 是单线程的，通常不会出现经典的死锁情况，但在某些情况下，可能会出现类似死锁的情况，我们称之为 &quot;事件循环阻塞&quot; 或 &quot;无限循环&quot;。</p><p>可能导致事件循环阻塞的情况：</p><ol><li>无限循环</li><li>递归调用没有正确的终止条件</li><li>同步 AJAX 请求</li></ol><p><strong>扩展</strong>: 为了避免事件循环阻塞，应该：</p><ol><li>使用异步操作处理耗时任务</li><li>将大任务分割成小任务，使用 setTimeout 等方法让出控制权</li><li>使用 Web Workers 处理复杂计算</li></ol><h2 id="题目9-什么是-任务分割-task-splitting-为什么它在-javascript-中很重要" tabindex="-1">题目9: 什么是 &quot;任务分割&quot;（Task splitting）？为什么它在 JavaScript 中很重要？ <a class="header-anchor" href="#题目9-什么是-任务分割-task-splitting-为什么它在-javascript-中很重要" aria-label="Permalink to &quot;题目9: 什么是 &quot;任务分割&quot;（Task splitting）？为什么它在 JavaScript 中很重要？&quot;">​</a></h2><p><strong>答案</strong>: 任务分割是将一个大任务分解成多个小任务的技术，每个小任务在事件循环的不同轮次中执行。</p><p>任务分割的重要性：</p><ol><li>防止长时间运行的脚本阻塞主线程</li><li>提高应用的响应性</li><li>允许浏览器在任务之间执行其他操作，如渲染更新</li></ol><p><strong>扩展</strong>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> chunk</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> doChunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> chunk;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 处理 array[index]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> array.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // 还有更多要处理，安排下一个块</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(doChunk, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    doChunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="题目10-解释一下-事件委托-event-delegation-及其与事件循环的关系。" tabindex="-1">题目10: 解释一下 &quot;事件委托&quot;（Event Delegation）及其与事件循环的关系。 <a class="header-anchor" href="#题目10-解释一下-事件委托-event-delegation-及其与事件循环的关系。" aria-label="Permalink to &quot;题目10: 解释一下 &quot;事件委托&quot;（Event Delegation）及其与事件循环的关系。&quot;">​</a></h2><p><strong>答案</strong>: 事件委托是一种事件处理模式，它利用事件冒泡，允许我们在父元素上添加一个事件监听器，来处理子元素上的事件。</p><p>事件委托的优点：</p><ol><li>减少事件监听器的数量，提高性能</li><li>动态添加的元素也能响应事件</li><li>减少内存使用</li></ol><p>事件委托与事件循环的关系：</p><ul><li>事件委托可以减少事件监听器的数量，从而减少事件循环中需要处理的任务数量</li><li>当事件触发时，事件处理函数会被添加到任务队列中，等待事件循环处理</li></ul><p><strong>扩展</strong>:</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;parent-list&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e.target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> e.target.nodeName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;LI&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;List item &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, e.target.id, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; was clicked!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>这个例子展示了如何使用事件委托来处理列表项的点击事件，而不需要为每个列表项单独添加事件监听器。</p>`,65),h=[l];function p(e,k,r,E,o,d){return i(),a("div",null,h)}const y=s(t,[["render",p]]);export{c as __pageData,y as default};
