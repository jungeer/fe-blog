# 代码分割

## 1. 什么是代码分割？它的主要目的是什么？
**答案**：代码分割是一种将代码分解成更小的块（或称为包）的技术，这些块可以按需加载或并行加载。其主要目的是：
1. 减少初始加载时间
2. 提高应用性能
3. 优化资源利用

## 2. 在 Webpack 中如何实现代码分割？
**答案**：在 Webpack 中实现代码分割的主要方法有：

1. 入口点分割：使用 entry 配置手动分割代码
2. 动态导入：使用 import() 语法
3. 防止重复：使用 SplitChunksPlugin 提取公共依赖

示例：
```javascript
// 使用动态导入
import('./module').then(module => {
  // 使用模块
});

// Webpack 配置
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
};
```

## 3. 什么是按需加载？如何在 React 中实现？
**答案**：按需加载是一种只在需要时才加载代码的技术。在 React 中，可以使用 React.lazy 和 Suspense 实现按需加载：

```jsx
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <OtherComponent />
    </Suspense>
  );
}
```

## 4. 什么是预加载（Preloading）和预获取（Prefetching）？它们的区别是什么？
**答案**：
- 预加载（Preloading）：立即加载资源，通常用于当前路由
- 预获取（Prefetching）：在浏览器闲置时加载资源，通常用于未来可能需要的路由

区别：
1. 优先级：预加载高于预获取
2. 执行时机：预加载立即执行，预获取在浏览器闲置时执行
3. 使用场景：预加载用于当前页面所需资源，预获取用于可能需要的future资源

## 5. 如何使用 Webpack 的魔法注释（Magic Comments）进行代码分割？
**答案**：Webpack 的魔法注释可以用于更细粒度地控制代码分割。例如：

```javascript
// 为chunk命名
import(/* webpackChunkName: "my-chunk-name" */ './module');

// 预获取
import(/* webpackPrefetch: true */ './module');

// 预加载
import(/* webpackPreload: true */ './module');
```

## 6. 什么是 Tree Shaking？它如何帮助优化代码体积？
**答案**：Tree Shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES6 模块语法的静态结构特性。

Tree Shaking 通过以下方式优化代码体积：
1. 识别并删除未使用的代码
2. 减少最终打包文件的大小
3. 提高应用加载速度和运行效率

在 Webpack 中启用 Tree Shaking：
```javascript
// webpack.config.js
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
  },
};
```

## 7. 什么是动态导入？它如何影响性能？
**答案**：动态导入是一种在运行时按需加载模块的技术。它通过 import() 函数实现，返回一个 Promise。

动态导入对性能的影响：
1. 减少初始加载时间
2. 按需加载资源，优化资源利用
3. 可能增加HTTP请求数，需要权衡

示例：
```javascript
button.addEventListener('click', event => {
  import('./dialogBox.js')
    .then(dialogBox => {
      dialogBox.open();
    })
    .catch(error => {
      /* Error handling */
    })
});
```

## 8. 在 Vue.js 中如何实现异步组件？
**答案**：在 Vue.js 中，可以使用动态导入来创建异步组件：

```javascript
const AsyncComponent = () => ({
  component: import('./MyComponent.vue'),
  loading: LoadingComponent,
  error: ErrorComponent,
  delay: 200,
  timeout: 3000
})

new Vue({
  // ...
  components: {
    'my-component': AsyncComponent
  }
})
```

## 9. 什么是 Code Splitting 的最佳实践？
**答案**：Code Splitting 的最佳实践包括：
1. 按路由分割：每个路由加载其所需的代码
2. 按组件分割：将大型组件拆分成更小的异步组件
3. 按功能分割：将不常用的功能单独分割
4. 提取公共依赖：使用 SplitChunksPlugin 提取共享模块
5. 使用动态导入：在适当的时机动态加载模块
6. 优化加载顺序：使用预加载和预获取
7. 监控和分析：使用工具如 Webpack Bundle Analyzer 分析包大小

## 10. 如何在单页应用（SPA）中优化首屏加载时间？
**答案**：优化 SPA 首屏加载时间的方法：
1. 路由级别的代码分割
2. 组件懒加载
3. 服务端渲染（SSR）
4. 静态站点生成（SSG）
5. 优化关键渲染路径
6. 使用缓存策略
7. 压缩资源（gzip, Brotli）
8. 使用 CDN
9. 优化字体加载
10. 实现骨架屏或加载占位符
